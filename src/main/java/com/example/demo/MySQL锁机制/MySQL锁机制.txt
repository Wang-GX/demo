
MySQL存储引擎：
MyISAM、MEMORY、InnoDB

表级锁:开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低。
行级锁:开销大，加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概率最低，并发度也最高。

MyISAM：
不支持事务
只支持表锁，MySQL的表级锁有两种模式:表共享读锁和表独占写锁。
执行查询语句时会对涉及到的表加读锁，执行更新语句时会对涉及到的表加写锁。
一旦数据表被加上读锁，其他请求可以对该表再次增加读锁，但是不能增加写锁。
    当一个进程在读数据时(加读锁)，其他进程也可以读，但是不能写。
一旦数据表被加上写锁，其他请求无法再对该表增加任何锁(读锁或写锁)。
    当一个进程在写数据时(加写锁)，其他进程不能执行任何读或写操作。
如果一个进程请求MyISAM表的表锁，同时另一个进程请求同一张表的读锁。默认情况下，MySQL会本着写锁优先的原则。

InnoDB：
支持事务
默认情况下,数据库处于自动提交模式。每一条语句处于一个单独的事务中,在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果执行失败则隐式的回滚事务。
支持行锁以及表锁，默认情况下加行锁。
执行查询语句时不会加任何锁(一致性非锁定读，可以手动加S锁或者X锁)，除非显示调用(这也导致了在并发请求下存在脏读、不可重复读、幻读的问题。事务的四种隔离级别正是在此基础上产生的)，执行更新语句时会对更新的行加写锁。
行锁的实现要求执行的SQL语句必须走索引(InnoDB的行锁是通过给索引加锁实现的)，否则会加表锁。通过索引可以快速到定位到数据，否则会进行全表扫描，所以会自动锁住整张表。
TODO InnoDB的表锁和MyISAM的表锁最好不要理解为一种锁

行共享读锁：
一旦索引被加上读锁，其他请求可以对该索引再次增加读锁，但是不能增加写锁。
    当一个事务对某几行加读锁时，其他事务可以读，但是不能写。
    上共享读锁的写法：lock in share mode
    例如：select * from table where id > 60 lock in share mode；
行排他写锁：
一旦索引被加上写锁，其他事务无法再在对该表增加任何锁(读锁或写锁)。
    当一个事务对某几行加写锁时，其他事务可以读，但是不能写。
    上排它锁的写法：for update
    例如：select * from table where id > 60 for update；

事务的隔离级别：
(1)读提交：一个事务只能读取到另一个事务已经提交的数据。
(2)可重复读(MySQL默认隔离级别)：
在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。


