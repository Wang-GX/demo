nginx可以通过命令行来启动，操作命令：

- 启动：start nginx.exe
- 停止：nginx.exe -s stop
- 重新加载：nginx.exe -s reload

redis命令参考：
http://redisdoc.com/




分布式锁1.0：
核心：SETNX key value：只在键key不存在的情况下，将键key的值设置为value。
问题1：线程抛出异常，delete代码无法执行，后续线程永远执行不成功
解决1：try-catch-finally，保证delete代码一定会执行

问题2：程序宕机，或者应用程序重启，此时如果delete代码还未执行，则redis中的key仍然存在
解决2：设置key超时时间

问题3：setnx和设置key超时时间这两步操作不是原子性的，可能会在中途被打断执行(如宕机)
解决3：使用：Boolean setIfAbsent(K var1, V var2, long var3, TimeUnit var5);
      代替：Boolean setIfAbsent(K var1, V var2);  +  Boolean expire(K key, long timeout, TimeUnit unit);
      由redis控制这两步的原子操作。

问题4：如果某个线程1加锁成功，但是由于某些原因执行时间超过锁设置的过期时间，此时锁过期自动释放。后续线程2仍然可以执行。
问题5：在问题4场景出现的基础上，如果线程2先执行结束，触发delete，此时线程1仍然没有执行结束，那么线程2释放的是线程1加的锁，此时无法保证执行的先后顺序。
       这两种情况在高并发的场景下可能导致锁"永久失效"。
解决5：为每个线程设置唯一标识(UUID)，加锁时作为value。释放锁时先去redis中判断是否是当前线程设置的value。
TODO 方法在栈中执行，局部变量不共享
解决4：无法精确地设置锁的超时时间。如果锁的超时时间设置较短，可能会出现问题4。但是如果锁的超时时间设置较长，那么一旦出现问题2，将会导致其他线程长时间无法执行。
       设置较短的超时时间，如3s，在线程1执行的同时开启一个新的线程执行定时任务，每隔1s去判断一下线程1设置的锁是否存在。
       如果存在则说明线程1还没有执行结束，重新设置key的超时时间(相当于延长)。
       如果不存在则说明线程1已结执行结束，结束定时任务。


分布式锁2.0
核心：Redisson框架
底层一系列的1ua脚本，lua脚本是原子代码块，由redis保证是原子执行的，执行过程中不会被其他redis命令打断。
问题：如果使用redis主从架构，主节点的键值会被同步到从节点。
      如果redis主节点宕机，当从节点被选取为新的主节点，如果此时锁还没有同步到从节点，那么后续线程仍然可以执行。